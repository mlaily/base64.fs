[{"uri":"/base64.fs/base64.html","title":"base64","content":"open System.Text\n\n/// Decompose a number in numerals according to the desired base (radix).\nlet splitNumerals radix (x: int) =\n    let rec splitNumerals\u0027 =\n        function\n        | head :: tail -\u003E\n            if head \u003C radix then head :: tail\n            else head % radix :: (splitNumerals\u0027 (head / radix :: tail))\n        | _ -\u003E failwith \u0022Don\u0027t call this function with an empty list!\u0022\n    splitNumerals\u0027 [ x ] |\u003E List.rev\n\n/// Returns the exponentiation result of a list of positional numerals\n/// in the desired base (radix).\nlet unsplitNumerals radix (xs: int list) =\n    (0, xs |\u003E List.rev |\u003E List.indexed)\n    ||\u003E List.fold (fun state (i, x) -\u003E state \u002B x * (pown radix i))\n\n/// Using the provided charset, returns a map of char -\u003E index in the charset.\nlet getCharsetIndexMap =\n    Array.indexed\n    \u003E\u003E Array.map (fun (x, y) -\u003E y, x)\n    \u003E\u003E Map.ofArray\n\ntype Pad = | Left | Right\nlet padList padType targetSize padValue (list: \u0027a list) =\n    if list.Length \u003E= targetSize then list\n    else\n        let padding = List.init (targetSize - list.Length) (fun _ -\u003E padValue)\n        match padType with\n        | Left -\u003E padding @ list\n        | Right -\u003E list @ padding\n\n// Standard base64 charset:\nlet base64Charset =\n      [ \u0027A\u0027 .. \u0027Z\u0027 ]\n    @ [ \u0027a\u0027 .. \u0027z\u0027 ]\n    @ [ \u00270\u0027 .. \u00279\u0027 ]\n    @ [ \u0027\u002B\u0027; \u0027/\u0027   ]\n    |\u003E Array.ofList\nlet base64CharsetIndices = getCharsetIndexMap base64Charset\n\n/// Encodes an array of bytes to a base64 string.\n/// (Note we don\u0027t bother adding padding chars)\nlet base64Encode (bytes: byte array) =\n    bytes\n    |\u003E List.ofArray\n    |\u003E List.collect ( // Make an uninterrupted string of bits from the input bytes:\n        int // Cast bytes to ints\n        \u003E\u003E splitNumerals 2 // Convert input bytes to bits (binary)\n        \u003E\u003E padList Left 8 0) // Pad with zeros so we have 8 bits for all input octets\n    |\u003E List.chunkBySize 6 // Split into sextets\n    |\u003E List.map (\n        padList Right 6 0 // Pad incomplete sextets with trailing zeros\n        \u003E\u003E unsplitNumerals 2 // Convert binary back to ints\n        \u003E\u003E (Array.get base64Charset)) // Map ints to chars\n    |\u003E System.String.Concat\n\n/// Decodes a base64 string into an array of bytes.\nlet base64Decode (str: string) =\n    str.TrimEnd(\u0027=\u0027).ToCharArray() // Remove trailing padding and split chars\n    |\u003E List.ofArray\n    |\u003E List.map (fun char -\u003E\n        base64CharsetIndices\n        |\u003E Map.find char) // Map chars back to ints\n    |\u003E List.collect ( // Recreate the uninterrupted bit string:\n        splitNumerals 2 // Convert ints to binary\n        \u003E\u003E padList Left 6 0) // Pad with zeros so we have 6 bits for all input sextets\n    |\u003E List.chunkBySize 8 // Regroup octets\n    |\u003E List.map (\n        unsplitNumerals 2 // Convert binary back to ints\n        \u003E\u003E byte) // Cast ints to bytes\n    |\u003E Array.ofList\n\nSystem.Convert.ToBase64String(Encoding.UTF8.GetBytes(\u0022Many hands make light work.\u0022))\n|\u003E printf \u0022%A\u0022\n\nbase64Encode (Encoding.UTF8.GetBytes(\u0022Many hands make light work.\u0022))\n|\u003E printf \u0022%A\u0022\n\nbase64Decode \u0022TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcmsu\u0022\n|\u003E Encoding.UTF8.GetString\n|\u003E printfn \u0022%A\u0022\n\nSystem.Convert.FromBase64String(\u0022TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcmsu\u0022)\n|\u003E Encoding.UTF8.GetString\n|\u003E printf \u0022%A\u0022"},{"uri":"/base64.fs/base64_fssnip.html","title":"base64_fssnip","content":"open System.Text\n\n// http://www.fssnip.net/7PR/title/Base64-Base32-Base16-encoding-and-decoding\n\n/// RFC 4648: The Base 64 Alphabet\nlet baseCharset = \u0022ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\u002B/=\u0022\n/// RFC 4648: The \u0022URL and Filename safe\u0022 Base 64 Alphabet\nlet safeCharset = \u0022ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\u0022\n\nlet encodeBase64 bytes =\n    let tripletToList ending (x, y, z) =\n      let A = safeCharset\n\n      let triplet = (int x \u003C\u003C\u003C 16)\n                ||| (int y \u003C\u003C\u003C  8)\n                ||| (int z)\n      let a = (triplet \u0026\u0026\u0026 0xFC0000) \u003E\u003E\u003E 18\n      let b = (triplet \u0026\u0026\u0026 0x03F000) \u003E\u003E\u003E 12\n      let c = (triplet \u0026\u0026\u0026 0x000FC0) \u003E\u003E\u003E  6\n      let d = (triplet \u0026\u0026\u0026 0x00003F)\n      match ending with\n      | 1 -\u003E [A.[a]; A.[b];  \u0027=\u0027 ;  \u0027=\u0027 ;] // 01==\n      | 2 -\u003E [A.[a]; A.[b]; A.[c];  \u0027=\u0027 ;] // \n      | _ -\u003E [A.[a]; A.[b]; A.[c]; A.[d];] // \n\n    let rec parse result input =\n      match input with\n      | a :: b :: c :: tail -\u003E parse (result @ tripletToList 3 (a, b, c)) tail\n      | a :: [b]            -\u003E result @ tripletToList 2 (a,   b, 0uy)\n      | [a]                 -\u003E result @ tripletToList 1 (a, 0uy, 0uy)\n      | []                  -\u003E result\n  \n    bytes\n    |\u003E Array.toList\n    |\u003E parse []\n    |\u003E List.toArray\n    |\u003E System.String.Concat\n\nlet decodeBase64 (text: string) = \n    if text.Length % 4 \u003C\u003E 0 then [||] else\n      let A = [for c in safeCharset -\u003E c]\n              |\u003E List.mapi (fun i a -\u003E a, i)\n              |\u003E Map.ofList\n\n      let (.@) (m: Map\u003Cchar, int\u003E) key = try m.[key] with _ -\u003E 0\n    \n      let quadToList ending (a, b, c, d) =\n        let quad = (A.@ a \u0026\u0026\u0026 0x3F \u003C\u003C\u003C 18)\n               ||| (A.@ b \u0026\u0026\u0026 0x3F \u003C\u003C\u003C 12)\n               ||| (A.@ c \u0026\u0026\u0026 0x3F \u003C\u003C\u003C  6)\n               ||| (A.@ d \u0026\u0026\u0026 0x3F)\n        let x = (quad \u0026\u0026\u0026 0xFF0000) \u003E\u003E\u003E 16\n        let y = (quad \u0026\u0026\u0026 0x00FF00) \u003E\u003E\u003E  8\n        let z = (quad \u0026\u0026\u0026 0x0000FF)\n        match ending with\n        | 2 -\u003E [byte x;]\n        | 3 -\u003E [byte x; byte y;]\n        | _ -\u003E [byte x; byte y; byte z;]\n    \n      let rec parse result input =\n        match input with\n        | a :: b ::\u0027=\u0027::[\u0027=\u0027]      -\u003E result @ quadToList 2 (a, b, \u0027=\u0027, \u0027=\u0027)\n        | a :: b :: c ::[\u0027=\u0027]      -\u003E result @ quadToList 3 (a, b,  c , \u0027=\u0027)\n        | a :: b :: c :: d :: tail -\u003E parse (result @ quadToList 4 (a, b, c, d)) tail\n        | _                        -\u003E result\n\n      [for c in text -\u003E c]\n      |\u003E parse []\n      |\u003E List.toArray\n\nencodeBase64 (Encoding.UTF8.GetBytes(\u0022Many hands make light work.\u0022))\n|\u003E printf \u0022%A\u0022\n\ndecodeBase64 \u0022TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcmsu\u0022\n|\u003E Encoding.UTF8.GetString\n|\u003E printf \u0022%A\u0022"},{"uri":"/base64.fs/index.html","title":"index","content":"// This is an empty file so fsdocs has an index..."}]